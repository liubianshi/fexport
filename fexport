#!/usr/bin/env perl
# vim: set ft=perl nowrap fdm=marker

# load module ================================================================= {{{1
use v5.20;
use strict;
use File::Basename;
use File::Spec;
use Getopt::Long;
use File::Temp qx/tempfile tempdir/;
use Cwd;
use feature qw( switch );
no warnings qw( experimental::smartmatch );

my $programdir = -l $0 ? dirname(readlink($0)) : dirname($0);
require(File::Spec->catfile($programdir, "rmd.pl"));

# parse parameters ====================================================== {{{1
Getopt::Long::Configure ("bundling");
GetOptions('to|t=s'      => \my $OUTFORMAT,
           'from|f=s'    => \my $FROM,
           'outfile|o=s' => \my $OUTFILE,
           'verbose|v'   => \my $VERBOSE,
           'pandoc|p=s'  => \my $PANDOC_OPTS_USER,
           'help|h'      => \my $HELP);
if ($HELP) { help(); exit 0 }

$SIG{INT}  = \&clean_temp_file;
$SIG{TERM} = \&clean_temp_file;
my ($LOG_FH, $LOG_FILE) = tempfile();
sub clean_temp_file {
    close $LOG_FH;
    unlink $LOG_FILE;
}

my $INFILE = $ARGV[0];
$FROM      //= $INFILE  =~ m/\.(\w+)$/  ?  $1  :  "md";
$OUTFORMAT //= $OUTFILE =~ m/\.(\w+)$/  ?  $1  :  "html";
$OUTFILE   //= $INFILE  =~ s/\.\w+$/.$OUTFORMAT/r;
($FROM, $OUTFORMAT) = map {lc} $FROM, $OUTFORMAT;

my $PANDOC_CMD          = "pandoc +RTS -M512M -RTS";
my $PANDOC_MARKDOWN     = "markdown+emoji+east_asian_line_breaks+autolink_bare_uris";
my @PANDOC_MARKDOWN_EXT = ("md", "markdown", "rmd", "rmarkdown");
my @PANDOC              = ($PANDOC_CMD,
                           $PANDOC_OPTS_USER // "",
                           "--from=" . ($FROM ~~ @PANDOC_MARKDOWN_EXT ? $PANDOC_MARKDOWN : $FROM),
                           "--lua-filter=rsbc.lua") ;

# parse input_file ============================================================ {{{1
my @MD_CONTENTS;
if ($FROM eq "md") {
    push @MD_CONTENTS, $_ while (<<>>);
}
elsif ($FROM eq "rmd") {
    my ($tpfh, $tpfile) = tempfile(suffix => '.rmd');
    unless (defined $INFILE) {
        print $tpfh $_ while (<>);
        close $tpfh;
    }
    my %rmdopt = rmd2md($INFILE // $tpfile, $OUTFORMAT, \@MD_CONTENTS,
                        \@PANDOC, $LOG_FILE); 
    $OUTFILE =~ s/\.\w+$/"." . $rmdopt{ext}/e;
    $OUTFORMAT = $rmdopt{to} // $rmdopt{ext};
}
else {
    die "$FROM wasn't supperted yet!" 
}

# adjust markdown contents ==================================================== {{{1
# transform markdown contest to target format ================================= {{{1
given ($OUTFORMAT) {
    when ("html") {
        push @PANDOC, pandoc_opts_default($OUTFORMAT), "--to=html", "--output=$OUTFILE";
        my @html_contents = ();
        md2array(\@MD_CONTENTS, \@html_contents, \@PANDOC);
        str_adj_etal(\@html_contents);
        str_adj_html(\@html_contents);
        write2file(\@html_contents, $OUTFILE);
    }
    when ("docx") {
        push @PANDOC, pandoc_opts_default($OUTFORMAT), "--to=docx", "--output=$OUTFILE";
        md2file(\@MD_CONTENTS, \@PANDOC);
        str_adj_word($OUTFILE);
    }
    when ("pdf") {
        my @tex_contents = ();
        my $dir = tempdir();
        my $intermidaite = File::Spec->catfile($dir, "intermidaite.tex");
        push @PANDOC, pandoc_opts_default("tex"), "--to=latex", "--output=-";

        str_adj_md_contents_for_tex(\@MD_CONTENTS);
        md2array(\@MD_CONTENTS, \@tex_contents, \@PANDOC);
        str_adj_tex(\@tex_contents);
        write2file(\@tex_contents, $intermidaite);
        system(qq{
            latexmk -xelatex -quiet -outdir="$dir" "$intermidaite" >>$LOG_FILE 2>>$LOG_FILE
            mv $dir/intermidaite.pdf "$OUTFILE"
        });
    }
    default {
        push @PANDOC, pandoc_opts_default($OUTFORMAT), "--to=$OUTFORMAT", "--output=$OUTFILE";
        md2file(\@MD_CONTENTS, \@PANDOC);
    }
}

if ($VERBOSE) {
    print $_ while (<$LOG_FH>);
}
say "$OUTFILE";
clean_temp_file(); 
exit 0;


# function needed to used ===================================================== {{{1 
# transform md content in array to target format in array --------------------- {{{2
sub md2array {
    my ($in_contents, $out_contents, $pandoc) = @_;
    md2file($in_contents, $pandoc);
    open my $read_content, '<', $OUTFILE or die "cannot open file $OUTFILE: $!";
    @{$out_contents} = <$read_content>;
    close $read_content;
}


# transform md contests in array to target file ------------------------- {{{2
sub md2file {
    my ($in_contents, $pandoc) = @_;
    open my $pandoc_fh, "|-", join(" ", @{$pandoc}) or die "cannot run pandoc: $!";
    print $pandoc_fh join "", @{$in_contents};
    close $pandoc_fh
}

# pandoc default options ------------------------------------------------ {{{2
sub pandoc_opts_default {
    my $to = shift;
    my ($datadir, $defaults, $defaultfile);
    $datadir = qx/pandoc --version | grep -E '^User data'/;
    $datadir =~ s/^.*\s*User data directory:\s*([^\s]+)\n/$1/;
    my $defaultfile = File::Spec->catfile($datadir, "defaults", "2$to.yaml");
    $defaults = "-d2$to" if -f $defaultfile;
    if (qx/uname/ =~ /^Darwin/) {
        $defaultfile  = File::Spec->catfile($datadir, "defaults", "2${to}_mac.yaml");
        $defaults = "-d2${to}_mac" if -f $defaultfile;
    }
    return($defaults // "");
}

# 调整参考文献文内引用中 “et al” 的显示格式 ----------------------------- {{{2
sub str_adj_etal {
    for (@{shift()}) {
        s{ ([a-zA-Z]) (,\s|\s) 等                    }{ $1$2et al. }gx;
        s{ \s (等 (?:\s\( | ,\s  | <\/a> | <\/w:t>)) }{ $1         }gx;
    }
}

# 替代文件内容 ---------------------------------------------------------- {{{2
sub str_adj_file {
    my ($file, $sub) = @_;

    open my $infh, "<", $file or "Cannot open $file: $!";
    my @contents = <$infh>;
    close $infh;

    $sub->(\@contents);
    open my $outfh, ">", $file or "Cannot open $file: $!";
    print $outfh join "", @contents;
}

# 对于 html 输出格式做特殊的文本替代处理 -------------------------------- {{{2
sub str_adj_html {
    my $cjk = qr/[^A-Za-z,."'';。；，：“”（）、？《》]/;
    for (@{shift()}) {
        s/([^A-Za-z,."';])\s(<span class="citation" data\-cites="[^\w])/$1$2/g;
        s/($cjk)(<span class="citation"[^>]+>(<a href=[^>]+>)?[A-Za-z])/$1 $2/g;
    }
}

# 对 tex 输出格式做特殊的调整 ------------------------------------------- {{{2
sub str_adj_md_contents_for_tex {
    my $content_ref = shift;
    my $math_sign = qr/\$\$/;
    my $eq_begin = qr/\\begin\{equa[^\}]+\}/;
    my $eq_end = qr/\\end\{equa[^\}]+\}/;

    for (@{$content_ref}) {
        s/$math_sign ($eq_begin)/$1/gx;
        s/($eq_end) [^\$]* $math_sign/$1/gx;
    }
}

sub str_adj_tex {
    my $content_ref = shift;
    my $words = qr/[\w\p{P}\s]*\p{Han}+[\w\p{P}\s]*/;
    my $quote_left = qr/\`/;
    my $quote_right = qr/\'/;

    for (@{$content_ref}) {
        s/$quote_left{2} ($words) $quote_right{2}/“$1”/gx; 
        s/$quote_left    ($words) $quote_right   /‘$1’/gx;
    }
}

# 查找替代 word 文件的部分字符 ------------------------------------------ {{{2
sub str_adj_word {
    my $file = shift;
    my $cwd = getcwd();
    my $dir = tempdir( CLEANUP => 1 );
    system(qq/unzip -q "$file" -d "$dir"/);
    chdir "$dir";

    my $document_name = File::Spec->catfile("word", "document.xml");
    str_adj_file($document_name, \&str_adj_word_documents);
    my $footnotes_name = File::Spec->catfile("word", "footnotes.xml");
    str_adj_file($footnotes_name, \&str_adj_word_fottnotes);

    system(qq/zip -r -q "$file" */);
    chdir $cwd;
}

sub str_adj_word_documents {
    my $contents = shift;
    str_adj_etal($contents);

    my $tag_start    = qr/ <w:r> <w:t \s xml:space="preserve"> /x;
    my $tag_end      = qr/ <\/w:t> <\/w:r>                     /x;
    my $digits_sign  = qr/ [^\(]+ \(\d{4},                     /x;

    for (@{$contents}) {
        s/$tag_start \s $tag_end ($tag_start $digits_sign)/$1/gx;
    }
}

sub str_adj_word_fottnotes {
    str_adj_etal(shift);
}

# 将数组中的内容写入指定文件 -------------------------------------------- {{{2
sub write2file {
    my ($content, $outfile) = @_;
    open my $fh, ">", $outfile or die "cannot open $outfile: $!";
    print $fh $_ for (@{$content});
    close $fh;
}

