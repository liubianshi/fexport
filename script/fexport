#!/usr/bin/env perl
# vim: set ft=perl nowrap fdm=marker

# load module ================================================================= {{{1
use v5.20;
use strict;
use warnings;
use Getopt::Long;
use List::Util   qw/any/;
use File::Copy   qw(copy move);
use File::Temp qw/tempfile tempdir/;
use File::Basename;
use File::Spec;
use Cwd        qw(getcwd abs_path);
use Data::Dump qw(dump);

use Fexport::Util qw(md2array md2file write2file pandoc_opts_default);
use Fexport::PostProcess qw(str_adj_etal str_adj_html str_adj_md_contents_for_tex str_adj_tex str_adj_word);
use Fexport::Rmd qw(knit_rmd2);
use Fexport::Quarto qw(render_qmd);

# parse parameters ====================================================== {{{1
Getopt::Long::Configure("bundling");
GetOptions(
  'to|t=s'      => \my $OUTFORMAT,
  'from|f=s'    => \my $FROM,
  'outfile|o=s' => \my $OUTFILE,
  'dirname|d=s' => \my $DIRNAME,
  'verbose|v'   => \my $VERBOSE,
  'pandoc|p=s'  => \my $PANDOC_OPTS_USER,
  'keep|k'      => \my $KEEP_INTERMEDIATES,
  'preview'     => \my $PREVIEW,
  'lang'        => \my $LANG,
  'help|h'      => \my $HELP
);
if ($HELP) { help(); exit 0 }
my @files_needed_clean = ();
local %SIG = ( %SIG, INT => \&clean_temp_file, TERM => \&clean_temp_file );
my ( $LOG_FH, $LOG_FILE ) = tempfile();

sub clean_temp_file {
  close $LOG_FH;
  unlink $LOG_FILE;
  unlink $_ for @files_needed_clean;
}
my $current_pwd = getcwd();
my $INFILE      = $ARGV[0];
if ( defined $INFILE and File::Spec->file_name_is_absolute($INFILE) ) {
  $DIRNAME //= dirname($INFILE);
  $INFILE = File::Spec->abs2rel( $INFILE, $DIRNAME );
}
chdir $DIRNAME if defined $DIRNAME;

$FROM      //= $INFILE  =~ m/\.(\w+)$/ ? $1 : "md";
$OUTFORMAT //= $OUTFILE =~ m/\.(\w+)$/ ? $1 : "html";
$OUTFILE   //= $INFILE  =~ s/\.\w+$/.$OUTFORMAT/r;
if ( File::Spec->file_name_is_absolute($OUTFILE) ) {
  $OUTFILE = File::Spec->abs2rel( $OUTFILE, getcwd() );
}
( $FROM, $OUTFORMAT ) = map { lc } $FROM, $OUTFORMAT;
$LANG //= "zh";

my $PANDOC_RUN          = 0;
my $PANDOC_CMD          = "pandoc +RTS -M512M -RTS";
my $PANDOC_MARKDOWN     = "markdown+emoji+east_asian_line_breaks+autolink_bare_uris";
my @PANDOC_MARKDOWN_EXT = ( "md", "markdown", "rmd", "rmarkdown", "qmd", "quarto" );
my @PANDOC_FILTERS =
  ( '--filter=pandoc-crossref', '--lua-filter=rm-test-table-line.lua', '--citeproc', '--lua-filter=rsbc.lua' );
my @PANDOC = (
  $PANDOC_CMD,
  '--from="' . ( any { $_ eq $FROM } @PANDOC_MARKDOWN_EXT ? $PANDOC_MARKDOWN : $FROM ) . '"',
  $VERBOSE ? '--verbose' : "",
  @PANDOC_FILTERS, $PANDOC_OPTS_USER // ""
);

# parse input_file ====================================================== {{{1
my @MD_CONTENTS;
if ( $FROM eq "md" ) {
  push @MD_CONTENTS, $_ while (<>);
}
elsif ( $FROM eq "rmd" ) {
  my ( $tpfh, $tpfile ) = tempfile( suffix => '.rmd' );
  unless ( defined $INFILE ) {
    print $tpfh $_ while (<>);
    close $tpfh;
  }
  my %rmdopt = knit_rmd2( $INFILE // $tpfile, $OUTFORMAT, \@MD_CONTENTS, \@PANDOC, $LOG_FILE );
  $OUTFORMAT = $rmdopt{to} // $rmdopt{ext};

  if (exists $rmdopt{files_needed_clean}) {
     push @files_needed_clean, @{$rmdopt{files_needed_clean}};
  }
  
  dump %rmdopt;
  if ( $rmdopt{run_pandoc} eq "no" ) {
    $OUTFILE =~ s/\.\w+$/"." . $rmdopt{ext}/e;
  }
  else {
    copy $rmdopt{outfile} => $OUTFILE unless $OUTFILE eq $rmdopt{outfile};
    $PANDOC_RUN = 1;
  }
}
elsif ( $FROM eq "qmd" or $FROM eq "quarto" ) {
  render_qmd( $INFILE, $OUTFORMAT, $OUTFILE, $LANG, $PREVIEW, $VERBOSE, $KEEP_INTERMEDIATES, $OUTFILE );
  exit 0;
}
else {
  die "$FROM wasn't supported yet!";
}

# transform markdown contest to target format =========================== {{{1
if ( $OUTFORMAT eq "html" ) {
  push @PANDOC, pandoc_opts_default($OUTFORMAT), "--to=html", "--output=\"$OUTFILE\"";
  my @html_contents = ();
  md2array( \@MD_CONTENTS, \@html_contents, \@PANDOC, $OUTFILE, $LOG_FH );
  str_adj_etal( \@html_contents );
  str_adj_html( \@html_contents );
  write2file( \@html_contents, $OUTFILE );
}
elsif ( $OUTFORMAT eq "docx" ) {
  unless ($PANDOC_RUN) {
    push @PANDOC, pandoc_opts_default($OUTFORMAT), "--to=docx", "--output=\"$OUTFILE\"";
    md2file( \@MD_CONTENTS, \@PANDOC, $LOG_FH );
  }
  str_adj_word($OUTFILE);
}
elsif ( $OUTFORMAT eq "pdf" ) {
  my @tex_contents = ();
  my $dir          = tempdir( CLEANUP => 1 );
  my $intermediate = File::Spec->catfile( $dir, "intermediate.tex" );
  $OUTFILE =~ s/pdf$/tex/;
  push @PANDOC, pandoc_opts_default("tex"), "--output=\"$OUTFILE\"", "--to=latex";

  str_adj_md_contents_for_tex( \@MD_CONTENTS );
  md2array( \@MD_CONTENTS, \@tex_contents, \@PANDOC, $OUTFILE, $LOG_FH );
  str_adj_tex( \@tex_contents );
  write2file( \@tex_contents, $intermediate );
  $OUTFILE =~ s/tex$/pdf/;
  my $pdfmk =
    $VERBOSE
    ? qq/latexmk -xelatex -outdir="$dir" "$intermediate"/
    : qq/latexmk -quiet -xelatex -outdir="$dir" "$intermediate"/;
  system(qq{ $pdfmk && mv $dir/intermediate.pdf "$OUTFILE" });
}
else {
  push @PANDOC, pandoc_opts_default($OUTFORMAT), "--to=$OUTFORMAT", "--output=\"$OUTFILE\"";
  md2file( \@MD_CONTENTS, \@PANDOC, $LOG_FH );
}

if ($VERBOSE) {
  print $_ while (<$LOG_FH>);
}
say "\n";
if   ( $current_pwd eq getcwd() ) { say "$OUTFILE" }
else                              { say abs_path($OUTFILE) }
clean_temp_file();
exit 0;

sub help {
    print "Usage: fexport [options] [file]\n";
    # ... Add fuller help if needed
}
