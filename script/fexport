#!/usr/bin/env perl
# vim: set ft=perl nowrap fdm=marker

use v5.20;
use strict;
use warnings;
use utf8;

# --- Core Dependencies ---
use Path::Tiny;
use Getopt::Long qw(:config bundling);
use List::Util   qw(any);
use Cwd          qw(getcwd);

# --- Fexport Modules ---
# 引入 Config 模块中的核心函数
use Fexport::Config      qw(load_config merge_config process_params);
use Fexport::Util        qw(run_pandoc save_lines);
use Fexport::PostProcess qw(postprocess_docx postprocess_html postprocess_latex);
use Fexport::Rmd         qw(render_rmd);
use Fexport::Quarto      qw(render_qmd);
use Fexport::Pandoc      qw(build_cmd);
use Fexport::Converter   qw(convert);

# --- Global Cleanup Handling ---
my @temp_files;
$SIG{INT} = $SIG{TERM} = sub {
  path($_)->remove for @temp_files;
  exit 1;
};

# ==============================================================================
# 1. 参数解析与配置合并 (Configuration)
# ==============================================================================
my %cli;
GetOptions(
  'to|t=s'      => \$cli{to},
  'from|f=s'    => \$cli{from},
  'outfile|o=s' => \$cli{outfile},
  'workdir=s'   => \$cli{workdir},
  'wd-mode=s'   => \$cli{wd_mode},           # 支持 file/cwd 模式
  'outdir|d=s'  => \$cli{outdir},
  'verbose|v'   => \$cli{verbose},
  'pandoc|p=s'  => \$cli{pandoc_opts},
  'config|c=s'  => \$cli{config},
  'keep|k'      => \$cli{keep},
  'preview'     => \$cli{preview},
  'lang=s'      => \$cli{lang},
  'help|h'      => sub { help(); exit 0 },
  )
  or die "Error parsing arguments. Use --help for usage.\n";

# A. 加载与合并配置
# 逻辑移交: Fexport::Config::merge_config 处理了 Defaults -> ConfigFile -> CLI 的优先级
my $file_config = load_config( $cli{config} );
my $opts        = merge_config( $file_config, \%cli );

# B. 路径解析与参数推断
# 逻辑移交: Fexport::Config::process_params 处理了所有复杂的路径计算、格式推断
my $infile_raw = $ARGV[0];
my $cwd_raw    = getcwd();

# process_params 返回: (工作目录, 绝对输入路径, 绝对输出路径)
# 注意: 这里假设你采纳了 Config 模块返回绝对路径的建议。
# 如果 Config 仍返回相对路径，下面需要用 $workdir->child() 包装一下。
my ( $work_dir_str, $infile_str, $outfile_str ) = process_params( $opts, $infile_raw, $cwd_raw );

# 转换为对象以便后续操作
my $workdir = path($work_dir_str);
my $outfile = path($outfile_str);
my $infile  = defined $infile_str ? path($infile_str) : undef;

# 此时 $opts->{from}, $opts->{to} 已经被 process_params 填充或推断完毕

# 切换工作目录 (如果需要)
# RMarkdown 和 Quarto 通常依赖相对路径资源，切换 CWD 是最安全的
if ( $workdir->stringify ne path(".")->absolute->stringify ) {
  chdir $workdir;
  say "[Info] Changed CWD to: $workdir" if $opts->{verbose};
}

# ==============================================================================
# 2. 构建 Pandoc 命令
# ==============================================================================
# 逻辑移交: Fexport::Pandoc::build_cmd 处理命令拼接
# $opts->{pandoc} 包含了来自配置文件的 filters, cmd 等设置
# $opts->{pandoc_opts} 包含了 CLI 传入的额外参数
my @pandoc_cmd = build_cmd(
  $opts->{pandoc},
  {
    from      => $opts->{from},
    verbose   => $opts->{verbose},
    user_opts => $opts->{pandoc_opts}
  }
);

# 准备日志文件
my $log_file = Path::Tiny->tempfile;
my $log_fh   = $log_file->openw;

# ==============================================================================
# 3. 处理输入源 (Markdown / Rmd / Quarto)
# ==============================================================================
my @md_lines;
my $is_external_done = 0;    # 标记是否由外部工具直接生成了最终文件

if ( $opts->{from} eq 'md' ) {

  # 分支 A: 纯 Markdown
  if ($infile) {
    @md_lines = $infile->lines_utf8;
  }
  else {
    # 处理 STDIN 输入
    @md_lines = <STDIN>;

    # 如果是 STDIN，process_params 会生成默认 outfile
  }
}
elsif ( $opts->{from} eq 'rmd' ) {

  # 分支 B: RMarkdown
  unless ($infile) {
    my $tmp = Path::Tiny->tempfile( SUFFIX => '.Rmd' );
    $tmp->spew_utf8(<STDIN>);
    $infile = $tmp;
    push @temp_files, $tmp;
  }

  # 调用 Fexport::Rmd::render_rmd
  # 这一步可能会产生中间 Markdown，也可能直接生成 PDF/Docx
  my $res = render_rmd( $infile, $opts->{to}, \@pandoc_cmd );

  # 注册需要清理的中间文件
  if ( $res->{clean_files} ) {
    push @temp_files, @{ $res->{clean_files} };
  }

  if ( $res->{md_lines} && @{ $res->{md_lines} } ) {

    # 情况 1: R 生成了中间 Markdown，需要 Perl 继续跑 Pandoc
    @md_lines = @{ $res->{md_lines} };
  }
  else {
    # 情况 2: R 直接生成了最终文件
    # 检查 R 的输出路径与我们的预期路径是否一致，不一致则移动
    my $r_out = $res->{meta}{outfile};
    if ($r_out) {
      my $r_out_path = path($r_out)->absolute;    # R 产生的路径通常相对于 workdir
      if ( $r_out_path ne $outfile ) {
        if ( $r_out_path->exists ) {
          $r_out_path->move($outfile);
        }
        else {
          warn "[Warn] R reported outfile '$r_out' but it does not exist.\n";
        }
      }
    }
    $is_external_done = 1;
  }
}
elsif ( $opts->{from} =~ /^(qmd|quarto)$/ ) {

  # 分支 C: Quarto
  render_qmd(
    $infile,
    $opts->{to},
    $outfile,    # 传入绝对路径
    $opts->{lang},
    $opts->{preview},
    $opts->{verbose},
    $opts->{keep},
    $outfile     # Quarto 模块 API 需要确认是否还需要这个参数
  );
  $is_external_done = 1;
}
else {
  die "Error: Unsupported input format '$opts->{from}'\n";
}

# ==============================================================================
# 4. 转换与后处理 (Conversion & Post-Processing)
# ==============================================================================

if ($is_external_done) {

  # 如果外部工具已完成生成，检查是否需要额外的 Perl 后处理
  # 例如：RMarkdown 生成的 Docx 可能仍需要 CJK 优化
  if ( $opts->{to} eq 'docx' && $opts->{from} eq 'rmd' ) {
    postprocess_docx($outfile);
  }

  # Quarto 模块内部已包含后处理逻辑，此处略过
}
else {
  # 标准 Pandoc 转换流程
  convert(
    {
      format      => $opts->{to},
      outfile     => $outfile->stringify,
      md_contents => \@md_lines,
      pandoc      => \@pandoc_cmd,
      log_fh      => $log_fh,
      verbose     => $opts->{verbose},
      keep        => $opts->{keep},
      preview     => $opts->{preview},      # Browser-Sync 预览
      lang        => $opts->{lang}
    }
  );
}

# ==============================================================================
# 5. 收尾工作
# ==============================================================================

# 输出日志
if ( $opts->{verbose} ) {
  close $log_fh;
  print $_ for $log_file->lines;
}

# 清理临时文件
unless ( $opts->{keep} ) {
  path($_)->remove for @temp_files;
}

# 输出最终结果路径 (如果是绝对路径，打印出来方便用户点击)
say "\nExported: " . $outfile;

exit 0;

sub help {
  require Pod::Usage;
  Pod::Usage::pod2usage( -verbose => 2 );
}

__END__

=head1 NAME

fexport - A wrapper tool to convert RMarkdown, Quarto, and Markdown to various formats.

=head1 SYNOPSIS

fexport [options] [file]

=head1 OPTIONS

=over 8

=item B<--to, -t>

Specify output format (html, pdf, docx, etc.). Default is html.

=item B<--from, -f>

Specify input format (md, rmd, qmd). Auto-detected from extension.

=item B<--outfile, -o>

Specify output filename.

=item B<--outdir, -d>

Specify output directory.

=item B<--workdir>

Specify working directory.

=item B<--config, -c>

Specify a YAML configuration file.

=item B<--pandoc, -p>

Pass extra options to pandoc (e.g. "-V geometry:margin=1in").

=item B<--verbose, -v>

Enable verbose output.

=item B<--keep, -k>

Keep intermediate files.

=item B<--preview>

Enable live preview (requires browser-sync).

=back

=cut
