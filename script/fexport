#!/usr/bin/env perl
# vim: set ft=perl nowrap fdm=marker

# load module ================================================================= {{{1
use v5.20;
use strict;
use warnings;
use Getopt::Long;
use List::Util   qw/any/;
use File::Copy   qw(copy move);
use File::Temp qw/tempfile tempdir/;
use File::Basename;
use File::Spec;
use Cwd        qw(getcwd abs_path);
use Data::Dump qw(dump);

use Fexport::Util qw(md2array md2file write2file pandoc_opts_default);
use Fexport::PostProcess qw(str_adj_etal str_adj_html str_adj_md_contents_for_tex str_adj_tex str_adj_word);
use Fexport::Rmd qw(knit_rmd2);
use Fexport::Quarto qw(render_qmd);

# parse parameters ====================================================== {{{1
Getopt::Long::Configure("bundling");
GetOptions(
  'to|t=s'      => \my $OUTFORMAT,
  'from|f=s'    => \my $FROM,
  'outfile|o=s' => \my $OUTFILE,
  'workdir=s'   => \my $WORKDIR,
  'outdir|d=s'  => \my $OUTDIR,
  'verbose|v'   => \my $VERBOSE,
  'pandoc|p=s'  => \my $PANDOC_OPTS_USER,
  'keep|k'      => \my $KEEP_INTERMEDIATES,
  'preview'     => \my $PREVIEW,
  'lang'        => \my $LANG,
  'help|h'      => \my $HELP
);
if ($HELP) { help(); exit 0 }
my @files_needed_clean = ();
local %SIG = ( %SIG, INT => \&clean_temp_file, TERM => \&clean_temp_file );
my ( $LOG_FH, $LOG_FILE ) = tempfile();

sub clean_temp_file {
  close $LOG_FH;
  unlink $LOG_FILE;
  unlink $_ for @files_needed_clean;
}
my $current_pwd = getcwd();
my $INFILE      = $ARGV[0];
if ( defined $INFILE and File::Spec->file_name_is_absolute($INFILE) ) {
  $WORKDIR //= dirname($INFILE);
  $INFILE = File::Spec->abs2rel( $INFILE, $WORKDIR );
}
chdir $WORKDIR if defined $WORKDIR;

$FROM      //= $INFILE  =~ m/\.(\w+)$/ ? $1 : "md";
$OUTFORMAT //= $OUTFILE =~ m/\.(\w+)$/ ? $1 : "html"; # Fallback format from outfile if possible

# Resolve absolute path for output file *before* changing usage directory
my $out_basename = defined $OUTFILE ? basename($OUTFILE) : basename($INFILE) =~ s/\.\w+$/.$OUTFORMAT/r;
# When outdir is undefined, use outfile's parent path (if outfile defined) or current pwd
my $out_dir      = $OUTDIR // (defined $OUTFILE ? dirname($OUTFILE) : $current_pwd);

# Ensure out_dir is absolute based on *current_pwd*
$out_dir = File::Spec->rel2abs($out_dir, $current_pwd) unless File::Spec->file_name_is_absolute($out_dir);
$OUTFILE = File::Spec->catfile($out_dir, $out_basename);

# Change working directory to input file's directory for proper resource resolution
# (Wait, we already did chdir $WORKDIR above if defined. If NOT defined, we didn't Chdir.
# But original code did: chdir $DIRNAME if defined $DIRNAME. And $DIRNAME was defaulted to dirname($INFILE).
# So we effectively ALWAYS chdir to input file dir unless relative path given and not absolute?)
# Let's check lines 48-52 in original.

( $FROM, $OUTFORMAT ) = map { lc } $FROM, $OUTFORMAT;
$LANG //= "zh";

my $PANDOC_RUN          = 0;
my $PANDOC_CMD          = "pandoc +RTS -M512M -RTS";
my $PANDOC_MARKDOWN     = "markdown+emoji+east_asian_line_breaks+autolink_bare_uris";
my @PANDOC_MARKDOWN_EXT = ( "md", "markdown", "rmd", "rmarkdown", "qmd", "quarto" );
my @PANDOC_FILTERS =
  ( '--filter=pandoc-crossref', '--lua-filter=rm-test-table-line.lua', '--citeproc', '--lua-filter=rsbc.lua' );
my @PANDOC = (
  $PANDOC_CMD,
  '--from="' . ( any { $_ eq $FROM } @PANDOC_MARKDOWN_EXT ? $PANDOC_MARKDOWN : $FROM ) . '"',
  $VERBOSE ? '--verbose' : "",
  @PANDOC_FILTERS, $PANDOC_OPTS_USER // ""
);

# parse input_file ====================================================== {{{1
my @MD_CONTENTS;
if ( $FROM eq "md" ) {
  push @MD_CONTENTS, $_ while (<>);
}
elsif ( $FROM eq "rmd" ) {
  my ( $tpfh, $tpfile ) = tempfile( suffix => '.rmd' );
  unless ( defined $INFILE ) {
    print $tpfh $_ while (<>);
    close $tpfh;
  }
  my %rmdopt = knit_rmd2( $INFILE // $tpfile, $OUTFORMAT, \@MD_CONTENTS, \@PANDOC, $LOG_FILE );
  $OUTFORMAT = $rmdopt{to} // $rmdopt{ext};

  if (exists $rmdopt{files_needed_clean}) {
     push @files_needed_clean, @{$rmdopt{files_needed_clean}};
  }
  
  dump %rmdopt;
  if ( $rmdopt{run_pandoc} eq "no" ) {
    $OUTFILE =~ s/\.\w+$/"." . $rmdopt{ext}/e;
  }
  else {
    copy $rmdopt{outfile} => $OUTFILE unless $OUTFILE eq $rmdopt{outfile};
    $PANDOC_RUN = 1;
  }
}
elsif ( $FROM eq "qmd" or $FROM eq "quarto" ) {
  render_qmd( $INFILE, $OUTFORMAT, $OUTFILE, $LANG, $PREVIEW, $VERBOSE, $KEEP_INTERMEDIATES, $OUTFILE );
}
else {
  die "$FROM wasn't supported yet!";
}

# transform markdown contest to target format =========================== {{{1
if ( $OUTFORMAT eq "html" ) {
  push @PANDOC, pandoc_opts_default($OUTFORMAT), "--to=html", "--output=\"$OUTFILE\"";
  my @html_contents = ();
  md2array( \@MD_CONTENTS, \@html_contents, \@PANDOC, $OUTFILE, $LOG_FH );
  str_adj_etal( \@html_contents );
  str_adj_html( \@html_contents );
  write2file( \@html_contents, $OUTFILE );
}
elsif ( $OUTFORMAT eq "docx" ) {
  unless ($PANDOC_RUN) {
    push @PANDOC, pandoc_opts_default($OUTFORMAT), "--to=docx", "--output=\"$OUTFILE\"";
    md2file( \@MD_CONTENTS, \@PANDOC, $LOG_FH );
  }
  str_adj_word($OUTFILE);
}
elsif ( $OUTFORMAT eq "pdf" ) {
  my @tex_contents = ();
  my $dir          = tempdir( CLEANUP => 1 );
  my $intermediate = File::Spec->catfile( $dir, "intermediate.tex" );
  $OUTFILE =~ s/pdf$/tex/;
  push @PANDOC, pandoc_opts_default("tex"), "--output=\"$OUTFILE\"", "--to=latex";

  str_adj_md_contents_for_tex( \@MD_CONTENTS );
  md2array( \@MD_CONTENTS, \@tex_contents, \@PANDOC, $OUTFILE, $LOG_FH );
  str_adj_tex( \@tex_contents );
  write2file( \@tex_contents, $intermediate );
  $OUTFILE =~ s/tex$/pdf/;
  my $pdfmk =
    $VERBOSE
    ? qq/latexmk -xelatex -outdir="$dir" "$intermediate"/
    : qq/latexmk -quiet -xelatex -outdir="$dir" "$intermediate"/;
  system(qq{ $pdfmk && mv $dir/intermediate.pdf "$OUTFILE" });
}
else {
  push @PANDOC, pandoc_opts_default($OUTFORMAT), "--to=$OUTFORMAT", "--output=\"$OUTFILE\"";
  md2file( \@MD_CONTENTS, \@PANDOC, $LOG_FH );
}

if ($VERBOSE) {
  print $_ while (<$LOG_FH>);
}
say "\n";
if   ( $current_pwd eq getcwd() ) { say "$OUTFILE" }
else                              { say abs_path($OUTFILE) }
clean_temp_file();
exit 0;

use Pod::Usage;

sub help {
    pod2usage(-verbose => 2);
}

__END__

=head1 NAME

fexport - Export RMarkdown/Quarto files to various formats (HTML, PDF, DOCX)

=head1 SYNOPSIS

fexport [options] [file]

=head1 OPTIONS

=over 8

=item B<--to, -t>

Specify output format (html, pdf, docx, etc.). Default is html.

=item B<--from, -f>

Specify input format (md, rmd, qmd, quarto). Auto-detected from file extension.

=item B<--outfile, -o>

Specify output filename.

=item B<--workdir>

Specify working directory.

=item B<--outdir, -d>

Specify output directory. Defaults to C<outfile>'s directory (if specified) or current working directory.

=item B<--verbose, -v>

Enable verbose output.

=item B<--pandoc, -p>

Pass extra options to pandoc.

=item B<--keep, -k>

Keep intermediate files (like .tex, .knit.md).

=item B<--preview>

Preview the output in browser (HTML only).

=item B<--lang>

Specify language (default: zh).

=item B<--help, -h>

Print this help message.

=back

=head1 DESCRIPTION

B<fexport> is a wrapper tool to convert RMarkdown (.rmd) and Quarto (.qmd) documents into various formats using Pandoc, R, and Quarto. It handles special post-processing for Chinese language support, bibliography formatting, and more.

=cut
